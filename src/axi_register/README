SimpleRegister4Zynq - This file is part of SimpleRegister4Zynq
Copyright (C) 2015 - Telecom ParisTech

This file must be used under the terms of the CeCILL.
This source file is licensed as described in the file COPYING, which
you should have received as part of this distribution.  The terms
are also available at
http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt

----------------------------
SIMPLE REGISTER DESIGN FILES
----------------------------

1) Content
----------

README:
  This file
boot.bin:
  Zynq boot image produced by bootgen. Embed a FSBL EFL, a PL bitstream and a U-Boot ELF
system.dtb:
  A Linux device tree blob
uImage:
  A Linux kernel image for U-Boot
uramdisk.image.gz:
  A ramdisk image for U-Boot (simple file system with busybox)
  
2) Short description
--------------------

The PL bitstream is that of a simple AXI register with one slave AXI port,
an 8-bits general purpose input and an 8 bits general purpose output:

---------+     +-------------------+
   PS    |     |  SIMPLE REGISTER  |
         |     |                   |
M_AXI_GP0|<--->|S_AXI<-->REGs      |
---------+     |                   |
               |                   |
 Switches ---->|GPI             GPO|----> LEDs
               +-------------------+

The S_AXI AXI slave port is used to access the registers. GPI and GPO are
general purpose 8 bits inputs and outputs. GPI is connected to the switches and
GPO to the LEDs. The mapping of the S_AXI address space is the following:

             +------------+
  0x40000000 |  GPIR (ro) | General purpose input register (8 LSBs only, 24 MSBs reserved)
             +------------+
  0x40000004 |  GPOR (rw) | General purpose output register (8 LSBs only, 24 MSBs reserved)
             +------------+

Reserved bits read as zeroes and writing them has no effect. Writing a read-only
(ro) register returns a SLVERR response. Accessing an unmapped address returns a
DECERR response. The value of GPIR least significant byte is always equal to the
GPI input. The value of least significant byte of GPO depends on the value of
GPIR (and thus GPI):

+-------+-------------------------------------------------+
| GPIR  | GPO                                             |
+-------+-------------------------------------------------+
| 0x00  | GPOR                                            |
+-------+-------------------------------------------------+
| other | 0x55                                            |
+-------+-------------------------------------------------+

3) Using the simple register on the ZedBoard
--------------------------------------------

a) Copy the provided files on a SD card
b) To avoid strange bugs, please cross-check the result of the copy:
   - compute the md5sum of the provided files,
   - copy the files on the SD card
   - sync and un-mount the SD card
   - mount the SD card again
   - compute the md5sum of the SD card files and compare with the originals
c) Configure the ZedBoard jumpers to boot from SD card (set MIO4 and MIO5, unset
   MIO2, MIO3 and MIO6), insert the SD card, plug the power and console USB
   cable and power on.
d) Launch a terminal emulator like minicom (minicom -D /dev/ttyACM0) and stop
   U-Boot by hitting the keyboard.
e) Set the following U-Boot environment variables:
     setenv bootcmd 'run $modeboot'
     setenv modeboot 'sdboot'
     setenv sdboot 'fatload mmc 0 0x3000000 uImage && fatload mmc 0 0x2000000 uramdisk.image.gz && fatload mmc 0 0x2a00000 system.dtb && bootm 0x3000000 0x2000000 0x2a00000'
   and save them on the QSPI flash:
     saveenv
   so that U-Boot remembers them for the next time.
f) Continue the boot sequence (boot), wait until Linux boots and start
   interacting with the register (with devmem, for instance).

4) Example of experiments
-------------------------

# First test the design in the PL by setting the switches to any configuration
# other than 0x00 and 0x01 (e.g. 0x02) and looking at the LEDs: if the LEDs
# illuminate in the 0x55 configuration things are probably OK, else the PL does
# not work as expected.

# Reading the current status of the 8 switches:
zynq> devmem 0x40000000 32
0x00000002

# Illuminating the 8 LEDs (first set the switches to 0x00):
zynq> devmem 0x40000004 32 0xFF

# Power off
zynq> poweroff
The system is going down NOW!
Sent SIGTERM to all processes
Sent SIGKILL to all processes
Requesting system poweroff
reboot: System halted

5) Building the whole example from scratch
------------------------------------------

#############################################################
# Fetch sources (if not already done, else simply git pull) #
#############################################################
export DISTRIB=<some-path>
export UBOOT=$DISTRIB/u-boot-xlnx
export KERNEL=$DISTRIB/linux-xlnx
export DEVICETREEXLNX=$DISTRIB/device-tree-xlnx
git clone http://github.com/Xilinx/u-boot-xlnx.git $UBOOT
git clone http://github.com/Xilinx/linux-xlnx.git $KERNEL
git clone http://github.com/Xilinx/device-tree-xlnx.git $DEVICETREEXLNX
cd $DISTRIB
wget http://www.wiki.xilinx.com/file/view/arm_ramdisk.image.gz

##########
# U-Boot #
##########
cd $UBOOT
git pull
export CROSS_COMPILE=arm-xilinx-linux-gnueabi-
make distclean
rm -rf build
make O=build zynq_zed_config all
export PATH=$PATH:$UBOOT/build/tools

##########
# rootfs #
##########
# cd $DISTRIB
# gunzip ramdisk.image.gz
# chmod u+rwx ramdisk.image
# mkdir tmp_mnt/
# sudo mount -o loop ramdisk.image tmp_mnt/
# # Modify tmp_mnt/
# sudo umount tmp_mnt/
# gzip ramdisk.image
mkimage -A arm -T ramdisk -C gzip -d arm_ramdisk.image.gz uramdisk.image.gz

################
# Linux kernel #
################
cd $KERNEL
git pull
export CROSS_COMPILE=arm-xilinx-linux-gnueabi-
make distclean
make ARCH=arm xilinx_zynq_defconfig
make ARCH=arm menuconfig
make ARCH=arm UIMAGE_LOADADDR=0x8000 uImage
export PATH=$KERNEL/scripts/dtc:$PATH

############################################
# Hardware and hardware dependant software #
############################################
export SIMPLEREGISTER4ZYNQ=<some-path>
export DESIGN=$SIMPLEREGISTER4ZYNQ/src/axi_register
cd $DESIGN
cp $UBOOT/build/u-boot u-boot.elf
make syn
make fsbl dtb bin
cp boot.bin axi_register_wrapper.vv-syn/top.sdk/dts/system.dtb $KERNEL/arch/arm/boot/uImage $DISTRIB/uramdisk.image.gz /media/SDCARD
sync
