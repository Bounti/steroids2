Copyright (C) Telecom ParisTech

This file must be used under the terms of the CeCILL.
This source file is licensed as described in the file COPYING, which
you should have received as part of this distribution.  The terms
are also available at
http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt

----------------------------
SIMPLE REGISTER DESIGN FILES
----------------------------

This directory and its sub-directories contain the VHDL source code, VHDL
simulation environment, simulation and synthesis scripts of a simple register
example for the Xilinx Zynq core.

1) Content
----------

COPYING:
COPYING-FR:
COPYRIGHT:
  Copyright notice and licences.

Makefile:
  The main Makefile. Type 'make' to see the available targets.

README:
  This file.

hwprj:
  The HWPrj git submodule. Contains all simulation and synthesis scripts.
  simpleregister4zynq follows the HWPrj infrastructure and organization. Please
  see hwprj/README for explanations about the HWPrj.

src/axi:
  The axi module (library axi_lib). Contains the axi_pkg package with
  all AXI-related declarations.

src/axi_register:
  The axi_register module (library axi_register_lib). The simple register and
  its wrapper. 

src/global:
  The global module (library global_lib). Several general purpose packages.

src/random:
  The random module (library random_lib). Random generators for simulation.

2) Short description
--------------------

The PL bitstream is that of a simple AXI register with one slave AXI port,
an 8-bits general purpose input and an 8 bits general purpose output:

---------+     +-------------------+
   PS    |     |  SIMPLE REGISTER  |
         |     |                   |
M_AXI_GP0|<--->|S_AXI<-->REGs      |
---------+     |                   |
               |                   |
 Switches ---->|GPI             GPO|----> LEDs
               +-------------------+

The S_AXI AXI slave port is used to access the registers. GPI and GPO are
general purpose 8 bits inputs and outputs. GPI is connected to the switches and
GPO to the LEDs. The mapping of the S_AXI address space is the following:

             +------------+
  0x40000000 |  GPIR (ro) | General purpose input register (8 LSBs only, 24 MSBs reserved)
             +------------+
  0x40000004 |  GPOR (rw) | General purpose output register (8 LSBs only, 24 MSBs reserved)
             +------------+

Reserved bits read as zeroes and writing them has no effect. Writing a read-only
(ro) register returns a SLVERR response. Accessing an unmapped address returns a
DECERR response. The value of GPIR least significant byte is always equal to the
GPI input. The value of least significant byte of GPO depends on the value of
GPIR (and thus GPI):

+-------+-------------------------------------------------+
| GPIR  | GPO                                             |
+-------+-------------------------------------------------+
| 0x00  | GPOR                                            |
+-------+-------------------------------------------------+
| other | 0x55                                            |
+-------+-------------------------------------------------+

3) Building the whole example from scratch
------------------------------------------

#############################################################
# Fetch sources (if not already done, else simply git pull) #
#############################################################
export DISTRIB=<some-path>
export SIMPLEREGISTER4ZYNQ=$DISTRIB/simpleregister4zynq
export UBOOT=$DISTRIB/u-boot-xlnx
export KERNEL=$DISTRIB/linux-xlnx
export DEVICETREEXLNX=$DISTRIB/device-tree-xlnx
git clone --recursive git@gitlab.eurecom.fr:renaud.pacalet/hwprj.git $SIMPLEREGISTER4ZYNQ
git clone http://github.com/Xilinx/u-boot-xlnx.git $UBOOT
git clone http://github.com/Xilinx/linux-xlnx.git $KERNEL
git clone http://github.com/Xilinx/device-tree-xlnx.git $DEVICETREEXLNX
cd $DISTRIB
wget http://www.wiki.xilinx.com/file/view/arm_ramdisk.image.gz

##########
# U-Boot #
##########
cd $UBOOT
git pull
export CROSS_COMPILE=arm-xilinx-linux-gnueabi-
make distclean
rm -rf build
make O=build zynq_zed_config all
export PATH=$PATH:$UBOOT/build/tools

##########
# rootfs #
##########
# Note: to modify the root file system before building the image:
# cd $DISTRIB
# gunzip ramdisk.image.gz
# chmod u+rwx ramdisk.image
# mkdir tmp_mnt/
# sudo mount -o loop ramdisk.image tmp_mnt/
## Modify tmp_mnt/
# sudo umount tmp_mnt/
# gzip ramdisk.image
mkimage -A arm -T ramdisk -C gzip -d arm_ramdisk.image.gz uramdisk.image.gz

################
# Linux kernel #
################
cd $KERNEL
git pull
export CROSS_COMPILE=arm-xilinx-linux-gnueabi-
make distclean
make ARCH=arm xilinx_zynq_defconfig
make ARCH=arm menuconfig
make ARCH=arm UIMAGE_LOADADDR=0x8000 uImage
export PATH=$KERNEL/scripts/dtc:$PATH

############################################
# Hardware and hardware dependant software #
############################################
export DESIGN=$SIMPLEREGISTER4ZYNQ/src/axi_register
cd $DESIGN
cp $UBOOT/build/u-boot u-boot.elf
make syn
make fsbl dtb bin
mkdir sdcard
cp axi_register_wrapper.vv-syn/top.sdk/dts/system.dtb sdcard
cp $KERNEL/arch/arm/boot/uImage sdcard
cp $DISTRIB/uramdisk.image.gz sdcard
cp boot.bin sdcard

4) Using the simple register on the ZedBoard
--------------------------------------------

a) Copy the provided files on a SD card:

cp boot.bin system.dtb uImage uramdisk.image.gz /media/SDCARD
sync

b) To avoid strange bugs, please cross-check the result of the copy:

   - compute the md5sum of the provided files,
   - copy the files on the SD card
   - sync and un-mount the SD card
   - mount the SD card again
   - compute the md5sum of the SD card files and compare with the originals

c) Configure the ZedBoard jumpers to boot from SD card (set MIO4 and MIO5, unset
   MIO2, MIO3 and MIO6), insert the SD card, plug the power and console USB
   cable and power on.

d) Launch a terminal emulator like minicom (minicom -D /dev/ttyACM0) and stop
   U-Boot by hitting the keyboard.

e) Set the following U-Boot environment variables:

     setenv bootcmd 'run $modeboot'
     setenv modeboot 'sdboot'
     setenv sdboot 'fatload mmc 0 0x3000000 uImage && fatload mmc 0 0x2000000 uramdisk.image.gz && fatload mmc 0 0x2a00000 system.dtb && bootm 0x3000000 0x2000000 0x2a00000'
   and save them on the QSPI flash:
     saveenv
   so that U-Boot remembers them for the next time.

f) Continue the boot sequence (boot), wait until Linux boots and start
   interacting with the register (with devmem, for instance).

5) Example of experiments
-------------------------

# First test the design in the PL by setting the switches to any configuration
# other than 0x00 (e.g. 0x02) and looking at the LEDs: if the LEDs illuminate in
# the 0x55 configuration things are probably OK, else the PL does not work as
# expected.

# Reading the current status of the 8 switches:
zynq> devmem 0x40000000 32
0x00000002

# Illuminating the 8 LEDs (first set the switches to 0x00):
zynq> devmem 0x40000004 32 0xFF

# Power off
zynq> poweroff
The system is going down NOW!
Sent SIGTERM to all processes
Sent SIGKILL to all processes
Requesting system poweroff
reboot: System halted
